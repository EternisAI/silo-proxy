// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: agent_connection_logs.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConnectionLog = `-- name: CreateConnectionLog :one
INSERT INTO agent_connection_logs (agent_id, connected_at, ip_address)
VALUES ($1, $2, $3) RETURNING id, agent_id, connected_at, disconnected_at, duration_seconds, ip_address, disconnect_reason
`

type CreateConnectionLogParams struct {
	AgentID     pgtype.UUID      `json:"agent_id"`
	ConnectedAt pgtype.Timestamp `json:"connected_at"`
	IpAddress   *netip.Addr      `json:"ip_address"`
}

func (q *Queries) CreateConnectionLog(ctx context.Context, arg CreateConnectionLogParams) (AgentConnectionLog, error) {
	row := q.db.QueryRow(ctx, createConnectionLog, arg.AgentID, arg.ConnectedAt, arg.IpAddress)
	var i AgentConnectionLog
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.DurationSeconds,
		&i.IpAddress,
		&i.DisconnectReason,
	)
	return i, err
}

const getAgentConnectionHistory = `-- name: GetAgentConnectionHistory :many
SELECT id, agent_id, connected_at, disconnected_at, duration_seconds, ip_address, disconnect_reason FROM agent_connection_logs
WHERE agent_id = $1
ORDER BY connected_at DESC
LIMIT $2 OFFSET $3
`

type GetAgentConnectionHistoryParams struct {
	AgentID pgtype.UUID `json:"agent_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetAgentConnectionHistory(ctx context.Context, arg GetAgentConnectionHistoryParams) ([]AgentConnectionLog, error) {
	rows, err := q.db.Query(ctx, getAgentConnectionHistory, arg.AgentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentConnectionLog{}
	for rows.Next() {
		var i AgentConnectionLog
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.ConnectedAt,
			&i.DisconnectedAt,
			&i.DurationSeconds,
			&i.IpAddress,
			&i.DisconnectReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConnectionLog = `-- name: UpdateConnectionLog :exec
UPDATE agent_connection_logs
SET disconnected_at = $2,
    duration_seconds = EXTRACT(EPOCH FROM ($2 - connected_at))::INT,
    disconnect_reason = $3
WHERE id = $1
`

type UpdateConnectionLogParams struct {
	ID               pgtype.UUID      `json:"id"`
	DisconnectedAt   pgtype.Timestamp `json:"disconnected_at"`
	DisconnectReason pgtype.Text      `json:"disconnect_reason"`
}

func (q *Queries) UpdateConnectionLog(ctx context.Context, arg UpdateConnectionLogParams) error {
	_, err := q.db.Exec(ctx, updateConnectionLog, arg.ID, arg.DisconnectedAt, arg.DisconnectReason)
	return err
}
